/*
 * generated by Xtext 2.9.2
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.myDsl.IDENTIFIER;
import org.xtext.example.mydsl.myDsl.Model;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.StringC;
import org.xtext.example.mydsl.myDsl.additive_expression;
import org.xtext.example.mydsl.myDsl.additive_expressionR;
import org.xtext.example.mydsl.myDsl.and_expression;
import org.xtext.example.mydsl.myDsl.and_expressionR;
import org.xtext.example.mydsl.myDsl.argument_expression_list;
import org.xtext.example.mydsl.myDsl.argument_expression_listR;
import org.xtext.example.mydsl.myDsl.assignment_expression;
import org.xtext.example.mydsl.myDsl.block_item_list;
import org.xtext.example.mydsl.myDsl.block_item_listR;
import org.xtext.example.mydsl.myDsl.cast_expression;
import org.xtext.example.mydsl.myDsl.conditional_expression;
import org.xtext.example.mydsl.myDsl.declaration;
import org.xtext.example.mydsl.myDsl.declaration_list;
import org.xtext.example.mydsl.myDsl.declaration_listR;
import org.xtext.example.mydsl.myDsl.declaration_specifiers;
import org.xtext.example.mydsl.myDsl.declarator;
import org.xtext.example.mydsl.myDsl.designator_list;
import org.xtext.example.mydsl.myDsl.designator_listR;
import org.xtext.example.mydsl.myDsl.direct_declarator;
import org.xtext.example.mydsl.myDsl.direct_declaratorR;
import org.xtext.example.mydsl.myDsl.equality_expression;
import org.xtext.example.mydsl.myDsl.equality_expressionR;
import org.xtext.example.mydsl.myDsl.exclusive_or_expression;
import org.xtext.example.mydsl.myDsl.exclusive_or_expressionR;
import org.xtext.example.mydsl.myDsl.expression;
import org.xtext.example.mydsl.myDsl.expressionR;
import org.xtext.example.mydsl.myDsl.function_definition;
import org.xtext.example.mydsl.myDsl.inclusive_or_expression;
import org.xtext.example.mydsl.myDsl.inclusive_or_expressionR;
import org.xtext.example.mydsl.myDsl.init_declarator;
import org.xtext.example.mydsl.myDsl.init_declarator_list;
import org.xtext.example.mydsl.myDsl.init_declarator_listR;
import org.xtext.example.mydsl.myDsl.initializer_list;
import org.xtext.example.mydsl.myDsl.initializer_listR;
import org.xtext.example.mydsl.myDsl.iteration_statement;
import org.xtext.example.mydsl.myDsl.labeled_statement;
import org.xtext.example.mydsl.myDsl.logical_and_expression;
import org.xtext.example.mydsl.myDsl.logical_and_expressionR;
import org.xtext.example.mydsl.myDsl.logical_or_expression;
import org.xtext.example.mydsl.myDsl.logical_or_expressionR;
import org.xtext.example.mydsl.myDsl.multiplicative_expression;
import org.xtext.example.mydsl.myDsl.multiplicative_expressionR;
import org.xtext.example.mydsl.myDsl.parameter_declaration;
import org.xtext.example.mydsl.myDsl.parameter_list;
import org.xtext.example.mydsl.myDsl.parameter_listR;
import org.xtext.example.mydsl.myDsl.pointer;
import org.xtext.example.mydsl.myDsl.postfix_expression;
import org.xtext.example.mydsl.myDsl.postfix_expressionR;
import org.xtext.example.mydsl.myDsl.relational_expression;
import org.xtext.example.mydsl.myDsl.relational_expressionR;
import org.xtext.example.mydsl.myDsl.selection_statement;
import org.xtext.example.mydsl.myDsl.shift_expressionR;
import org.xtext.example.mydsl.myDsl.specifier_qualifier_list;
import org.xtext.example.mydsl.myDsl.struct_declaration;
import org.xtext.example.mydsl.myDsl.struct_declaration_list;
import org.xtext.example.mydsl.myDsl.struct_declaration_listR;
import org.xtext.example.mydsl.myDsl.struct_declarator;
import org.xtext.example.mydsl.myDsl.struct_declarator_list;
import org.xtext.example.mydsl.myDsl.struct_declarator_listR;
import org.xtext.example.mydsl.myDsl.struct_or_union_specifier;
import org.xtext.example.mydsl.myDsl.translation_unit;
import org.xtext.example.mydsl.myDsl.translation_unitR;
import org.xtext.example.mydsl.myDsl.type_name;
import org.xtext.example.mydsl.myDsl.type_qualifier_list;
import org.xtext.example.mydsl.myDsl.type_qualifier_listR;
import org.xtext.example.mydsl.myDsl.unary_expression;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.IDENTIFIER:
				if (rule == grammarAccess.getJump_statementRule()
						|| rule == grammarAccess.getDesignatorRule()
						|| rule == grammarAccess.getStruct_or_union_specifierRule()
						|| rule == grammarAccess.getPrimary_expressionRule()
						|| rule == grammarAccess.getIDENTIFIERRule()
						|| rule == grammarAccess.getType_specifierRule()) {
					sequence_IDENTIFIER(context, (IDENTIFIER) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getParameter_declarationRule()
						|| rule == grammarAccess.getDeclaration_specifiersRule()) {
					sequence_IDENTIFIER_declaration_specifiers(context, (IDENTIFIER) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDeclaratorRule()
						|| rule == grammarAccess.getDirect_declaratorRule()
						|| rule == grammarAccess.getInit_declaratorRule()
						|| rule == grammarAccess.getStruct_declaratorRule()) {
					sequence_IDENTIFIER_direct_declarator(context, (IDENTIFIER) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIdentifier_listRRule()) {
					sequence_IDENTIFIER_identifier_listR(context, (IDENTIFIER) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIdentifier_listRule()) {
					sequence_IDENTIFIER_identifier_list(context, (IDENTIFIER) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBlock_itemRule()
						|| rule == grammarAccess.getStatementRule()) {
					sequence_IDENTIFIER_labeled_statement(context, (IDENTIFIER) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLabeled_statementRule()) {
					sequence_IDENTIFIER_labeled_statement(context, (IDENTIFIER) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPostfix_expressionRRule()) {
					sequence_IDENTIFIER_postfix_expressionR(context, (IDENTIFIER) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MyDslPackage.STRING_C:
				sequence_primary_expression(context, (StringC) semanticObject); 
				return; 
			case MyDslPackage.ADDITIVE_EXPRESSION:
				if (rule == grammarAccess.getAdditive_expressionRule()) {
					sequence_additive_expression(context, (additive_expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getShift_expressionRule()) {
					sequence_additive_expression_shift_expression(context, (additive_expression) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.ADDITIVE_EXPRESSION_R:
				sequence_additive_expressionR(context, (additive_expressionR) semanticObject); 
				return; 
			case MyDslPackage.AND_EXPRESSION:
				sequence_and_expression(context, (and_expression) semanticObject); 
				return; 
			case MyDslPackage.AND_EXPRESSION_R:
				sequence_and_expressionR(context, (and_expressionR) semanticObject); 
				return; 
			case MyDslPackage.ARGUMENT_EXPRESSION_LIST:
				sequence_argument_expression_list(context, (argument_expression_list) semanticObject); 
				return; 
			case MyDslPackage.ARGUMENT_EXPRESSION_LIST_R:
				sequence_argument_expression_listR(context, (argument_expression_listR) semanticObject); 
				return; 
			case MyDslPackage.ASSIGNMENT_EXPRESSION:
				sequence_assignment_expression(context, (assignment_expression) semanticObject); 
				return; 
			case MyDslPackage.BLOCK_ITEM_LIST:
				sequence_block_item_list(context, (block_item_list) semanticObject); 
				return; 
			case MyDslPackage.BLOCK_ITEM_LIST_R:
				sequence_block_item_listR(context, (block_item_listR) semanticObject); 
				return; 
			case MyDslPackage.CAST_EXPRESSION:
				sequence_cast_expression(context, (cast_expression) semanticObject); 
				return; 
			case MyDslPackage.CONDITIONAL_EXPRESSION:
				sequence_conditional_expression(context, (conditional_expression) semanticObject); 
				return; 
			case MyDslPackage.DECLARATION:
				sequence_declaration(context, (declaration) semanticObject); 
				return; 
			case MyDslPackage.DECLARATION_LIST:
				sequence_declaration_list(context, (declaration_list) semanticObject); 
				return; 
			case MyDslPackage.DECLARATION_LIST_R:
				sequence_declaration_listR(context, (declaration_listR) semanticObject); 
				return; 
			case MyDslPackage.DECLARATION_SPECIFIERS:
				sequence_declaration_specifiers(context, (declaration_specifiers) semanticObject); 
				return; 
			case MyDslPackage.DECLARATOR:
				sequence_declarator(context, (declarator) semanticObject); 
				return; 
			case MyDslPackage.DESIGNATOR_LIST:
				sequence_designator_list(context, (designator_list) semanticObject); 
				return; 
			case MyDslPackage.DESIGNATOR_LIST_R:
				sequence_designator_listR(context, (designator_listR) semanticObject); 
				return; 
			case MyDslPackage.DIRECT_DECLARATOR:
				sequence_direct_declarator(context, (direct_declarator) semanticObject); 
				return; 
			case MyDslPackage.DIRECT_DECLARATOR_R:
				sequence_direct_declaratorR(context, (direct_declaratorR) semanticObject); 
				return; 
			case MyDslPackage.EQUALITY_EXPRESSION:
				sequence_equality_expression(context, (equality_expression) semanticObject); 
				return; 
			case MyDslPackage.EQUALITY_EXPRESSION_R:
				sequence_equality_expressionR(context, (equality_expressionR) semanticObject); 
				return; 
			case MyDslPackage.EXCLUSIVE_OR_EXPRESSION:
				sequence_exclusive_or_expression(context, (exclusive_or_expression) semanticObject); 
				return; 
			case MyDslPackage.EXCLUSIVE_OR_EXPRESSION_R:
				sequence_exclusive_or_expressionR(context, (exclusive_or_expressionR) semanticObject); 
				return; 
			case MyDslPackage.EXPRESSION:
				sequence_expression(context, (expression) semanticObject); 
				return; 
			case MyDslPackage.EXPRESSION_R:
				sequence_expressionR(context, (expressionR) semanticObject); 
				return; 
			case MyDslPackage.FUNCTION_DEFINITION:
				sequence_function_definition(context, (function_definition) semanticObject); 
				return; 
			case MyDslPackage.INCLUSIVE_OR_EXPRESSION:
				sequence_inclusive_or_expression(context, (inclusive_or_expression) semanticObject); 
				return; 
			case MyDslPackage.INCLUSIVE_OR_EXPRESSION_R:
				sequence_inclusive_or_expressionR(context, (inclusive_or_expressionR) semanticObject); 
				return; 
			case MyDslPackage.INIT_DECLARATOR:
				sequence_init_declarator(context, (init_declarator) semanticObject); 
				return; 
			case MyDslPackage.INIT_DECLARATOR_LIST:
				sequence_init_declarator_list(context, (init_declarator_list) semanticObject); 
				return; 
			case MyDslPackage.INIT_DECLARATOR_LIST_R:
				sequence_init_declarator_listR(context, (init_declarator_listR) semanticObject); 
				return; 
			case MyDslPackage.INITIALIZER_LIST:
				sequence_initializer_list(context, (initializer_list) semanticObject); 
				return; 
			case MyDslPackage.INITIALIZER_LIST_R:
				sequence_initializer_listR(context, (initializer_listR) semanticObject); 
				return; 
			case MyDslPackage.ITERATION_STATEMENT:
				sequence_iteration_statement(context, (iteration_statement) semanticObject); 
				return; 
			case MyDslPackage.LABELED_STATEMENT:
				sequence_labeled_statement(context, (labeled_statement) semanticObject); 
				return; 
			case MyDslPackage.LOGICAL_AND_EXPRESSION:
				sequence_logical_and_expression(context, (logical_and_expression) semanticObject); 
				return; 
			case MyDslPackage.LOGICAL_AND_EXPRESSION_R:
				sequence_logical_and_expressionR(context, (logical_and_expressionR) semanticObject); 
				return; 
			case MyDslPackage.LOGICAL_OR_EXPRESSION:
				sequence_logical_or_expression(context, (logical_or_expression) semanticObject); 
				return; 
			case MyDslPackage.LOGICAL_OR_EXPRESSION_R:
				sequence_logical_or_expressionR(context, (logical_or_expressionR) semanticObject); 
				return; 
			case MyDslPackage.MULTIPLICATIVE_EXPRESSION:
				sequence_multiplicative_expression(context, (multiplicative_expression) semanticObject); 
				return; 
			case MyDslPackage.MULTIPLICATIVE_EXPRESSION_R:
				sequence_multiplicative_expressionR(context, (multiplicative_expressionR) semanticObject); 
				return; 
			case MyDslPackage.PARAMETER_DECLARATION:
				sequence_parameter_declaration(context, (parameter_declaration) semanticObject); 
				return; 
			case MyDslPackage.PARAMETER_LIST:
				sequence_parameter_list(context, (parameter_list) semanticObject); 
				return; 
			case MyDslPackage.PARAMETER_LIST_R:
				sequence_parameter_listR(context, (parameter_listR) semanticObject); 
				return; 
			case MyDslPackage.POINTER:
				sequence_pointer(context, (pointer) semanticObject); 
				return; 
			case MyDslPackage.POSTFIX_EXPRESSION:
				sequence_postfix_expression(context, (postfix_expression) semanticObject); 
				return; 
			case MyDslPackage.POSTFIX_EXPRESSION_R:
				sequence_postfix_expressionR(context, (postfix_expressionR) semanticObject); 
				return; 
			case MyDslPackage.RELATIONAL_EXPRESSION:
				sequence_relational_expression(context, (relational_expression) semanticObject); 
				return; 
			case MyDslPackage.RELATIONAL_EXPRESSION_R:
				sequence_relational_expressionR(context, (relational_expressionR) semanticObject); 
				return; 
			case MyDslPackage.SELECTION_STATEMENT:
				sequence_selection_statement(context, (selection_statement) semanticObject); 
				return; 
			case MyDslPackage.SHIFT_EXPRESSION_R:
				sequence_shift_expressionR(context, (shift_expressionR) semanticObject); 
				return; 
			case MyDslPackage.SPECIFIER_QUALIFIER_LIST:
				if (rule == grammarAccess.getParameter_declarationRule()
						|| rule == grammarAccess.getDeclaration_specifiersRule()) {
					sequence_declaration_specifiers_specifier_qualifier_list(context, (specifier_qualifier_list) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getType_nameRule()
						|| rule == grammarAccess.getSpecifier_qualifier_listRule()
						|| rule == grammarAccess.getStruct_declarationRule()
						|| rule == grammarAccess.getAtomic_type_specifierRule()
						|| rule == grammarAccess.getType_specifierRule()) {
					sequence_specifier_qualifier_list(context, (specifier_qualifier_list) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.STRUCT_DECLARATION:
				sequence_struct_declaration(context, (struct_declaration) semanticObject); 
				return; 
			case MyDslPackage.STRUCT_DECLARATION_LIST:
				sequence_struct_declaration_list(context, (struct_declaration_list) semanticObject); 
				return; 
			case MyDslPackage.STRUCT_DECLARATION_LIST_R:
				sequence_struct_declaration_listR(context, (struct_declaration_listR) semanticObject); 
				return; 
			case MyDslPackage.STRUCT_DECLARATOR:
				sequence_struct_declarator(context, (struct_declarator) semanticObject); 
				return; 
			case MyDslPackage.STRUCT_DECLARATOR_LIST:
				sequence_struct_declarator_list(context, (struct_declarator_list) semanticObject); 
				return; 
			case MyDslPackage.STRUCT_DECLARATOR_LIST_R:
				sequence_struct_declarator_listR(context, (struct_declarator_listR) semanticObject); 
				return; 
			case MyDslPackage.STRUCT_OR_UNION_SPECIFIER:
				if (rule == grammarAccess.getParameter_declarationRule()
						|| rule == grammarAccess.getDeclaration_specifiersRule()) {
					sequence_declaration_specifiers_struct_or_union_specifier(context, (struct_or_union_specifier) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStruct_or_union_specifierRule()
						|| rule == grammarAccess.getType_specifierRule()) {
					sequence_struct_or_union_specifier(context, (struct_or_union_specifier) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.TRANSLATION_UNIT:
				sequence_translation_unit(context, (translation_unit) semanticObject); 
				return; 
			case MyDslPackage.TRANSLATION_UNIT_R:
				sequence_translation_unitR(context, (translation_unitR) semanticObject); 
				return; 
			case MyDslPackage.TYPE_NAME:
				if (rule == grammarAccess.getParameter_declarationRule()
						|| rule == grammarAccess.getDeclaration_specifiersRule()) {
					sequence_declaration_specifiers_type_name(context, (type_name) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getType_nameRule()
						|| rule == grammarAccess.getAtomic_type_specifierRule()
						|| rule == grammarAccess.getType_specifierRule()) {
					sequence_type_name(context, (type_name) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.TYPE_QUALIFIER_LIST:
				sequence_type_qualifier_list(context, (type_qualifier_list) semanticObject); 
				return; 
			case MyDslPackage.TYPE_QUALIFIER_LIST_R:
				sequence_type_qualifier_listR(context, (type_qualifier_listR) semanticObject); 
				return; 
			case MyDslPackage.UNARY_EXPRESSION:
				sequence_unary_expression(context, (unary_expression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     jump_statement returns IDENTIFIER
	 *     designator returns IDENTIFIER
	 *     struct_or_union_specifier returns IDENTIFIER
	 *     primary_expression returns IDENTIFIER
	 *     IDENTIFIER returns IDENTIFIER
	 *     type_specifier returns IDENTIFIER
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_IDENTIFIER(ISerializationContext context, IDENTIFIER semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.IDENTIFIER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.IDENTIFIER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIDENTIFIERAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     parameter_declaration returns IDENTIFIER
	 *     declaration_specifiers returns IDENTIFIER
	 *
	 * Constraint:
	 *     (name=ID ds=declaration_specifiers?)
	 */
	protected void sequence_IDENTIFIER_declaration_specifiers(ISerializationContext context, IDENTIFIER semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     declarator returns IDENTIFIER
	 *     direct_declarator returns IDENTIFIER
	 *     init_declarator returns IDENTIFIER
	 *     struct_declarator returns IDENTIFIER
	 *
	 * Constraint:
	 *     (name=ID dr=direct_declaratorR?)
	 */
	protected void sequence_IDENTIFIER_direct_declarator(ISerializationContext context, IDENTIFIER semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     identifier_listR returns IDENTIFIER
	 *
	 * Constraint:
	 *     (name=ID rec+=identifier_listR*)
	 */
	protected void sequence_IDENTIFIER_identifier_listR(ISerializationContext context, IDENTIFIER semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     identifier_list returns IDENTIFIER
	 *
	 * Constraint:
	 *     (name=ID il=identifier_listR?)
	 */
	protected void sequence_IDENTIFIER_identifier_list(ISerializationContext context, IDENTIFIER semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     block_item returns IDENTIFIER
	 *     statement returns IDENTIFIER
	 *
	 * Constraint:
	 *     (name=ID a=statement?)
	 */
	protected void sequence_IDENTIFIER_labeled_statement(ISerializationContext context, IDENTIFIER semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     labeled_statement returns IDENTIFIER
	//
	// Constraint:
	//     (name=ID a=statement)
	//
	// protected void sequence_IDENTIFIER_labeled_statement(ISerializationContext context, IDENTIFIER semanticObject) { }
	
	/**
	 * Contexts:
	 *     postfix_expressionR returns IDENTIFIER
	 *
	 * Constraint:
	 *     (name=ID (rec+=postfix_expressionR+ | rec+=postfix_expressionR+)?)
	 */
	protected void sequence_IDENTIFIER_postfix_expressionR(ISerializationContext context, IDENTIFIER semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     greetings+=translation_unit+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     additive_expressionR returns additive_expressionR
	 *
	 * Constraint:
	 *     (
	 *         (Multiplicative_expression=multiplicative_expression rec+=additive_expressionR*) | 
	 *         (Multiplicative_expression=multiplicative_expression rec+=additive_expressionR*)
	 *     )
	 */
	protected void sequence_additive_expressionR(ISerializationContext context, additive_expressionR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     additive_expression returns additive_expression
	 *
	 * Constraint:
	 *     (Multiplicative_expression=multiplicative_expression Additive_expressionR=additive_expressionR?)
	 */
	protected void sequence_additive_expression(ISerializationContext context, additive_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     shift_expression returns additive_expression
	 *
	 * Constraint:
	 *     (Multiplicative_expression=multiplicative_expression Additive_expressionR=additive_expressionR? Shift_expressionR=shift_expressionR?)
	 */
	protected void sequence_additive_expression_shift_expression(ISerializationContext context, additive_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     and_expressionR returns and_expressionR
	 *
	 * Constraint:
	 *     (Equality_expression=equality_expression rec+=and_expressionR*)
	 */
	protected void sequence_and_expressionR(ISerializationContext context, and_expressionR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     and_expression returns and_expression
	 *
	 * Constraint:
	 *     (Equality_expression=equality_expression And_expressionR=and_expressionR?)
	 */
	protected void sequence_and_expression(ISerializationContext context, and_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     argument_expression_listR returns argument_expression_listR
	 *
	 * Constraint:
	 *     (Assignment_expression=assignment_expression rec+=argument_expression_listR*)
	 */
	protected void sequence_argument_expression_listR(ISerializationContext context, argument_expression_listR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     argument_expression_list returns argument_expression_list
	 *
	 * Constraint:
	 *     (Assignment_expression=assignment_expression Argument_expression_listR=argument_expression_listR?)
	 */
	protected void sequence_argument_expression_list(ISerializationContext context, argument_expression_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     assignment_expression returns assignment_expression
	 *     initializer returns assignment_expression
	 *
	 * Constraint:
	 *     (Unary_expression=unary_expression Assignment_operator=assignment_operator rec+=assignment_expression*)
	 */
	protected void sequence_assignment_expression(ISerializationContext context, assignment_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     block_item_listR returns block_item_listR
	 *
	 * Constraint:
	 *     (Block_item=block_item rec+=block_item_listR*)
	 */
	protected void sequence_block_item_listR(ISerializationContext context, block_item_listR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     compound_statement returns block_item_list
	 *     block_item_list returns block_item_list
	 *     block_item returns block_item_list
	 *     statement returns block_item_list
	 *
	 * Constraint:
	 *     (Block_item=block_item Block_item_listR=block_item_listR?)
	 */
	protected void sequence_block_item_list(ISerializationContext context, block_item_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     cast_expression returns cast_expression
	 *
	 * Constraint:
	 *     (Type_name=type_name rec+=cast_expression*)
	 */
	protected void sequence_cast_expression(ISerializationContext context, cast_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     external_declaration returns conditional_expression
	 *     block_item returns conditional_expression
	 *     declaration returns conditional_expression
	 *     conditional_expression returns conditional_expression
	 *     assignment_expression returns conditional_expression
	 *     initializer returns conditional_expression
	 *     designator returns conditional_expression
	 *     constant_expression returns conditional_expression
	 *     struct_declaration returns conditional_expression
	 *     struct_declarator returns conditional_expression
	 *     static_assert_declaration returns conditional_expression
	 *
	 * Constraint:
	 *     (Logical_or_expression=logical_or_expression Expression=expression rec+=conditional_expression*)
	 */
	protected void sequence_conditional_expression(ISerializationContext context, conditional_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     external_declaration returns declaration
	 *     block_item returns declaration
	 *     declaration returns declaration
	 *
	 * Constraint:
	 *     (Declaration_specifiers=declaration_specifiers Init_declarator_list=init_declarator_list)
	 */
	protected void sequence_declaration(ISerializationContext context, declaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXTERNAL_DECLARATION__DECLARATION_SPECIFIERS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXTERNAL_DECLARATION__DECLARATION_SPECIFIERS));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DECLARATION__INIT_DECLARATOR_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DECLARATION__INIT_DECLARATOR_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeclarationAccess().getDeclaration_specifiersDeclaration_specifiersParserRuleCall_0_0_0(), semanticObject.getDeclaration_specifiers());
		feeder.accept(grammarAccess.getDeclarationAccess().getInit_declarator_listInit_declarator_listParserRuleCall_0_1_0(), semanticObject.getInit_declarator_list());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     declaration_listR returns declaration_listR
	 *
	 * Constraint:
	 *     (Declaration=declaration rec+=declaration_listR*)
	 */
	protected void sequence_declaration_listR(ISerializationContext context, declaration_listR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     declaration_list returns declaration_list
	 *
	 * Constraint:
	 *     (Declaration=declaration Declaration_listR=declaration_listR?)
	 */
	protected void sequence_declaration_list(ISerializationContext context, declaration_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     parameter_declaration returns declaration_specifiers
	 *     declaration_specifiers returns declaration_specifiers
	 *
	 * Constraint:
	 *     (
	 *         (Storage_class_specifier=storage_class_specifier r1+=declaration_specifiers*) | 
	 *         ds=declaration_specifiers | 
	 *         (Type_qualifier=type_qualifier r2+=declaration_specifiers*)
	 *     )
	 */
	protected void sequence_declaration_specifiers(ISerializationContext context, declaration_specifiers semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     parameter_declaration returns specifier_qualifier_list
	 *     declaration_specifiers returns specifier_qualifier_list
	 *
	 * Constraint:
	 *     (Type_specifier=type_specifier rec+=specifier_qualifier_list* ds=declaration_specifiers?)
	 */
	protected void sequence_declaration_specifiers_specifier_qualifier_list(ISerializationContext context, specifier_qualifier_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     parameter_declaration returns struct_or_union_specifier
	 *     declaration_specifiers returns struct_or_union_specifier
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (Struct_or_union=struct_or_union Struct_declaration_list=struct_declaration_list) | 
	 *             (Struct_or_union=struct_or_union id=IDENTIFIER Struct_declaration_list=struct_declaration_list)
	 *         ) 
	 *         ds=declaration_specifiers?
	 *     )
	 */
	protected void sequence_declaration_specifiers_struct_or_union_specifier(ISerializationContext context, struct_or_union_specifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     parameter_declaration returns type_name
	 *     declaration_specifiers returns type_name
	 *
	 * Constraint:
	 *     (Specifier_qualifier_list=specifier_qualifier_list ad=abstract_declarator ds=declaration_specifiers?)
	 */
	protected void sequence_declaration_specifiers_type_name(ISerializationContext context, type_name semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     declarator returns declarator
	 *     init_declarator returns declarator
	 *     struct_declarator returns declarator
	 *
	 * Constraint:
	 *     (Pointer=pointer dd=direct_declarator)
	 */
	protected void sequence_declarator(ISerializationContext context, declarator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DECLARATOR__POINTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DECLARATOR__POINTER));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DECLARATOR__DD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DECLARATOR__DD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeclaratorAccess().getPointerPointerParserRuleCall_0_0_0(), semanticObject.getPointer());
		feeder.accept(grammarAccess.getDeclaratorAccess().getDdDirect_declaratorParserRuleCall_0_1_0(), semanticObject.getDd());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     designator_listR returns designator_listR
	 *
	 * Constraint:
	 *     (Designator=designator rec+=designator_listR*)
	 */
	protected void sequence_designator_listR(ISerializationContext context, designator_listR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     designation returns designator_list
	 *     designator_list returns designator_list
	 *
	 * Constraint:
	 *     (Designator=designator DesignatorR=designator_listR?)
	 */
	protected void sequence_designator_list(ISerializationContext context, designator_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     direct_declaratorR returns direct_declaratorR
	 *
	 * Constraint:
	 *     (
	 *         rec+=direct_declaratorR+ | 
	 *         rec+=direct_declaratorR+ | 
	 *         (Type_qualifier_list=type_qualifier_list Assignment_expression=assignment_expression rec+=direct_declaratorR*) | 
	 *         (Assignment_expression=assignment_expression rec+=direct_declaratorR*) | 
	 *         (Type_qualifier_list=type_qualifier_list rec+=direct_declaratorR*) | 
	 *         (Type_qualifier_list=type_qualifier_list Assignment_expression=assignment_expression rec+=direct_declaratorR*) | 
	 *         (Type_qualifier_list=type_qualifier_list Assignment_expression=assignment_expression rec+=direct_declaratorR*) | 
	 *         (Type_qualifier_list=type_qualifier_list rec+=direct_declaratorR*) | 
	 *         (Assignment_expression=assignment_expression rec+=direct_declaratorR*) | 
	 *         (Parameter_type_list=parameter_type_list rec+=direct_declaratorR*) | 
	 *         rec+=direct_declaratorR+ | 
	 *         (Identifier_list=identifier_list rec+=direct_declaratorR*)
	 *     )
	 */
	protected void sequence_direct_declaratorR(ISerializationContext context, direct_declaratorR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     declarator returns direct_declarator
	 *     direct_declarator returns direct_declarator
	 *     init_declarator returns direct_declarator
	 *     struct_declarator returns direct_declarator
	 *
	 * Constraint:
	 *     (Declarator=declarator Direct_declaratorR=direct_declaratorR?)
	 */
	protected void sequence_direct_declarator(ISerializationContext context, direct_declarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     equality_expressionR returns equality_expressionR
	 *
	 * Constraint:
	 *     (
	 *         (Relational_expression=relational_expression rec+=equality_expressionR*) | 
	 *         (Relational_expression=relational_expression rec+=equality_expressionR*)
	 *     )
	 */
	protected void sequence_equality_expressionR(ISerializationContext context, equality_expressionR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     equality_expression returns equality_expression
	 *
	 * Constraint:
	 *     (Relational_expression=relational_expression Equality_expressionR=equality_expressionR?)
	 */
	protected void sequence_equality_expression(ISerializationContext context, equality_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     exclusive_or_expressionR returns exclusive_or_expressionR
	 *
	 * Constraint:
	 *     (And_expression=and_expression rec+=exclusive_or_expressionR*)
	 */
	protected void sequence_exclusive_or_expressionR(ISerializationContext context, exclusive_or_expressionR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     exclusive_or_expression returns exclusive_or_expression
	 *
	 * Constraint:
	 *     (And_expression=and_expression Exclusive_or_expressionR=exclusive_or_expressionR?)
	 */
	protected void sequence_exclusive_or_expression(ISerializationContext context, exclusive_or_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     expressionR returns expressionR
	 *
	 * Constraint:
	 *     (Assignment_expression=assignment_expression rec+=expressionR*)
	 */
	protected void sequence_expressionR(ISerializationContext context, expressionR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     block_item returns expression
	 *     statement returns expression
	 *     jump_statement returns expression
	 *     expression_statement returns expression
	 *     expression returns expression
	 *     primary_expression returns expression
	 *
	 * Constraint:
	 *     (Assignment_expression=assignment_expression ExpressionR=expressionR?)
	 */
	protected void sequence_expression(ISerializationContext context, expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     external_declaration returns function_definition
	 *     function_definition returns function_definition
	 *
	 * Constraint:
	 *     (
	 *         (Declaration_specifiers=declaration_specifiers Declarator=declarator Declaration_list=declaration_list Compound_statement=compound_statement) | 
	 *         (Declaration_specifiers=declaration_specifiers Declarator=declarator Compound_statement=compound_statement)
	 *     )
	 */
	protected void sequence_function_definition(ISerializationContext context, function_definition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     inclusive_or_expressionR returns inclusive_or_expressionR
	 *
	 * Constraint:
	 *     (Exclusive_or_expression=exclusive_or_expression rec+=inclusive_or_expressionR*)
	 */
	protected void sequence_inclusive_or_expressionR(ISerializationContext context, inclusive_or_expressionR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     inclusive_or_expression returns inclusive_or_expression
	 *
	 * Constraint:
	 *     (Exclusive_or_expression=exclusive_or_expression Inclusive_or_expressionR=inclusive_or_expressionR?)
	 */
	protected void sequence_inclusive_or_expression(ISerializationContext context, inclusive_or_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     init_declarator returns init_declarator
	 *
	 * Constraint:
	 *     (Declarator=declarator Initializer=initializer)
	 */
	protected void sequence_init_declarator(ISerializationContext context, init_declarator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.INIT_DECLARATOR__DECLARATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.INIT_DECLARATOR__DECLARATOR));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.INIT_DECLARATOR__INITIALIZER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.INIT_DECLARATOR__INITIALIZER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInit_declaratorAccess().getDeclaratorDeclaratorParserRuleCall_0_0_0(), semanticObject.getDeclarator());
		feeder.accept(grammarAccess.getInit_declaratorAccess().getInitializerInitializerParserRuleCall_0_2_0(), semanticObject.getInitializer());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     init_declarator_listR returns init_declarator_listR
	 *
	 * Constraint:
	 *     (Init_declarator=init_declarator rec+=init_declarator_listR*)
	 */
	protected void sequence_init_declarator_listR(ISerializationContext context, init_declarator_listR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     init_declarator_list returns init_declarator_list
	 *
	 * Constraint:
	 *     (Init_declarator=init_declarator Init_declarator_listR=init_declarator_listR?)
	 */
	protected void sequence_init_declarator_list(ISerializationContext context, init_declarator_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     initializer_listR returns initializer_listR
	 *
	 * Constraint:
	 *     ((Designation=designation Initializer=initializer rec+=initializer_listR*) | (Initializer=initializer rec+=initializer_listR*))
	 */
	protected void sequence_initializer_listR(ISerializationContext context, initializer_listR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     initializer returns initializer_list
	 *     initializer_list returns initializer_list
	 *
	 * Constraint:
	 *     ((Designation=designation Initializer=initializer il=initializer_listR?) | (Initializer=initializer ilr=initializer_listR?))
	 */
	protected void sequence_initializer_list(ISerializationContext context, initializer_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     block_item returns iteration_statement
	 *     statement returns iteration_statement
	 *     iteration_statement returns iteration_statement
	 *
	 * Constraint:
	 *     (
	 *         (Expression=expression Statement=statement) | 
	 *         (Statement=statement Expression=expression) | 
	 *         (Expression_statement=expression_statement Expression_statement=expression_statement Statement=statement) | 
	 *         (Expression_statement=expression_statement Expression_statement=expression_statement Expression=expression Statement=statement) | 
	 *         (Declaration=declaration Expression_statement=expression_statement Statement=statement) | 
	 *         (Declaration=declaration Expression_statement=expression_statement Expression=expression Statement=statement)
	 *     )
	 */
	protected void sequence_iteration_statement(ISerializationContext context, iteration_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     block_item returns labeled_statement
	 *     statement returns labeled_statement
	 *     labeled_statement returns labeled_statement
	 *
	 * Constraint:
	 *     ((Constant_expression=constant_expression Statement=statement) | b=statement)
	 */
	protected void sequence_labeled_statement(ISerializationContext context, labeled_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     logical_and_expressionR returns logical_and_expressionR
	 *
	 * Constraint:
	 *     (Inclusive_or_expression=inclusive_or_expression rec+=logical_and_expressionR*)
	 */
	protected void sequence_logical_and_expressionR(ISerializationContext context, logical_and_expressionR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     logical_and_expression returns logical_and_expression
	 *
	 * Constraint:
	 *     (Inclusive_or_expression=inclusive_or_expression Logical_and_expressionR=logical_and_expressionR?)
	 */
	protected void sequence_logical_and_expression(ISerializationContext context, logical_and_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     logical_or_expressionR returns logical_or_expressionR
	 *
	 * Constraint:
	 *     (Logical_and_expression=logical_and_expression rec+=logical_or_expressionR*)
	 */
	protected void sequence_logical_or_expressionR(ISerializationContext context, logical_or_expressionR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     external_declaration returns logical_or_expression
	 *     block_item returns logical_or_expression
	 *     declaration returns logical_or_expression
	 *     conditional_expression returns logical_or_expression
	 *     logical_or_expression returns logical_or_expression
	 *     assignment_expression returns logical_or_expression
	 *     initializer returns logical_or_expression
	 *     designator returns logical_or_expression
	 *     constant_expression returns logical_or_expression
	 *     struct_declaration returns logical_or_expression
	 *     struct_declarator returns logical_or_expression
	 *     static_assert_declaration returns logical_or_expression
	 *
	 * Constraint:
	 *     (Logical_and_expression=logical_and_expression Logical_or_expressionR=logical_or_expressionR?)
	 */
	protected void sequence_logical_or_expression(ISerializationContext context, logical_or_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     multiplicative_expressionR returns multiplicative_expressionR
	 *
	 * Constraint:
	 *     (
	 *         (Cast_expression=cast_expression rec+=multiplicative_expressionR*) | 
	 *         (Cast_expression=cast_expression rec+=multiplicative_expressionR*) | 
	 *         (Cast_expression=cast_expression rec+=multiplicative_expressionR*)
	 *     )
	 */
	protected void sequence_multiplicative_expressionR(ISerializationContext context, multiplicative_expressionR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     multiplicative_expression returns multiplicative_expression
	 *
	 * Constraint:
	 *     (Cast_expression=cast_expression Multiplicative_expressionR=multiplicative_expressionR?)
	 */
	protected void sequence_multiplicative_expression(ISerializationContext context, multiplicative_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     parameter_declaration returns parameter_declaration
	 *
	 * Constraint:
	 *     (
	 *         (Declaration_specifiers2=declaration_specifiers Declarator1=declarator) | 
	 *         (Declaration_specifiers1=declaration_specifiers Abstract_declarator=abstract_declarator)
	 *     )
	 */
	protected void sequence_parameter_declaration(ISerializationContext context, parameter_declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     parameter_listR returns parameter_listR
	 *
	 * Constraint:
	 *     (Parameter_declaration=parameter_declaration rec+=parameter_listR*)
	 */
	protected void sequence_parameter_listR(ISerializationContext context, parameter_listR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     parameter_type_list returns parameter_list
	 *     parameter_list returns parameter_list
	 *
	 * Constraint:
	 *     (Parameter_declaration=parameter_declaration Parameter_listR=parameter_listR?)
	 */
	protected void sequence_parameter_list(ISerializationContext context, parameter_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     abstract_declarator returns pointer
	 *     pointer returns pointer
	 *
	 * Constraint:
	 *     ((Type_qualifier_list=type_qualifier_list rec+=pointer*) | rec+=pointer+)
	 */
	protected void sequence_pointer(ISerializationContext context, pointer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     postfix_expressionR returns postfix_expressionR
	 *
	 * Constraint:
	 *     (
	 *         (Expression=expression rec+=postfix_expressionR*) | 
	 *         rec+=postfix_expressionR+ | 
	 *         (Argument_expression_list=argument_expression_list rec+=postfix_expressionR*) | 
	 *         rec+=postfix_expressionR+ | 
	 *         rec+=postfix_expressionR+
	 *     )
	 */
	protected void sequence_postfix_expressionR(ISerializationContext context, postfix_expressionR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     cast_expression returns postfix_expression
	 *     unary_expression returns postfix_expression
	 *     postfix_expression returns postfix_expression
	 *
	 * Constraint:
	 *     (
	 *         (Primary_expression=primary_expression Postfix_expressionR=postfix_expressionR?) | 
	 *         (Type_name=type_name Initializer_list=initializer_list Postfix_expressionR=postfix_expressionR?) | 
	 *         (Type_name=type_name Initializer_list=initializer_list Postfix_expressionR=postfix_expressionR?)
	 *     )
	 */
	protected void sequence_postfix_expression(ISerializationContext context, postfix_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     primary_expression returns StringC
	 *
	 * Constraint:
	 *     string=STRING_C
	 */
	protected void sequence_primary_expression(ISerializationContext context, StringC semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STRING_C__STRING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STRING_C__STRING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimary_expressionAccess().getStringSTRING_CTerminalRuleCall_3_1_0(), semanticObject.getString());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     relational_expressionR returns relational_expressionR
	 *
	 * Constraint:
	 *     (
	 *         (Shift_expression=shift_expression rec+=relational_expressionR*) | 
	 *         (Shift_expression=shift_expression rec+=relational_expressionR*) | 
	 *         (Shift_expression=shift_expression rec+=relational_expressionR*) | 
	 *         (Shift_expression=shift_expression rec+=relational_expressionR*)
	 *     )
	 */
	protected void sequence_relational_expressionR(ISerializationContext context, relational_expressionR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     relational_expression returns relational_expression
	 *
	 * Constraint:
	 *     (Shift_expression=shift_expression re=relational_expressionR?)
	 */
	protected void sequence_relational_expression(ISerializationContext context, relational_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     block_item returns selection_statement
	 *     statement returns selection_statement
	 *     selection_statement returns selection_statement
	 *
	 * Constraint:
	 *     (
	 *         (Expression=expression Statement=statement Statement=statement) | 
	 *         (Expression=expression Statement=statement) | 
	 *         (Expression=expression Statement=statement)
	 *     )
	 */
	protected void sequence_selection_statement(ISerializationContext context, selection_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     shift_expressionR returns shift_expressionR
	 *
	 * Constraint:
	 *     ((Additive_expression=additive_expression rec+=shift_expressionR*) | (Additive_expression=additive_expression rec+=shift_expressionR*))
	 */
	protected void sequence_shift_expressionR(ISerializationContext context, shift_expressionR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type_name returns specifier_qualifier_list
	 *     specifier_qualifier_list returns specifier_qualifier_list
	 *     struct_declaration returns specifier_qualifier_list
	 *     atomic_type_specifier returns specifier_qualifier_list
	 *     type_specifier returns specifier_qualifier_list
	 *
	 * Constraint:
	 *     (Type_specifier=type_specifier rec+=specifier_qualifier_list*)
	 */
	protected void sequence_specifier_qualifier_list(ISerializationContext context, specifier_qualifier_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     struct_declaration_listR returns struct_declaration_listR
	 *
	 * Constraint:
	 *     (Struct_declaration=struct_declaration rec+=struct_declaration_listR*)
	 */
	protected void sequence_struct_declaration_listR(ISerializationContext context, struct_declaration_listR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     struct_declaration_list returns struct_declaration_list
	 *
	 * Constraint:
	 *     (Struct_declaration=struct_declaration Struct_declaration_listR=struct_declaration_listR?)
	 */
	protected void sequence_struct_declaration_list(ISerializationContext context, struct_declaration_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     struct_declaration returns struct_declaration
	 *
	 * Constraint:
	 *     (Specifier_qualifier_listx=specifier_qualifier_list Struct_declarator_list=struct_declarator_list)
	 */
	protected void sequence_struct_declaration(ISerializationContext context, struct_declaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATION__SPECIFIER_QUALIFIER_LISTX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATION__SPECIFIER_QUALIFIER_LISTX));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATION__STRUCT_DECLARATOR_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATION__STRUCT_DECLARATOR_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStruct_declarationAccess().getSpecifier_qualifier_listxSpecifier_qualifier_listParserRuleCall_1_0_0(), semanticObject.getSpecifier_qualifier_listx());
		feeder.accept(grammarAccess.getStruct_declarationAccess().getStruct_declarator_listStruct_declarator_listParserRuleCall_1_1_0(), semanticObject.getStruct_declarator_list());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     struct_declarator_listR returns struct_declarator_listR
	 *
	 * Constraint:
	 *     (Struct_declarator=struct_declarator rec+=struct_declarator_listR*)
	 */
	protected void sequence_struct_declarator_listR(ISerializationContext context, struct_declarator_listR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     struct_declarator_list returns struct_declarator_list
	 *
	 * Constraint:
	 *     (Struct_declarator=struct_declarator Struct_declarator_listR=struct_declarator_listR?)
	 */
	protected void sequence_struct_declarator_list(ISerializationContext context, struct_declarator_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     struct_declarator returns struct_declarator
	 *
	 * Constraint:
	 *     (Declaratorx=declarator Constant_expression1=constant_expression)
	 */
	protected void sequence_struct_declarator(ISerializationContext context, struct_declarator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATOR__DECLARATORX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATOR__DECLARATORX));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATOR__CONSTANT_EXPRESSION1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATOR__CONSTANT_EXPRESSION1));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStruct_declaratorAccess().getDeclaratorxDeclaratorParserRuleCall_1_0_0(), semanticObject.getDeclaratorx());
		feeder.accept(grammarAccess.getStruct_declaratorAccess().getConstant_expression1Constant_expressionParserRuleCall_1_2_0(), semanticObject.getConstant_expression1());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     struct_or_union_specifier returns struct_or_union_specifier
	 *     type_specifier returns struct_or_union_specifier
	 *
	 * Constraint:
	 *     (
	 *         (Struct_or_union=struct_or_union Struct_declaration_list=struct_declaration_list) | 
	 *         (Struct_or_union=struct_or_union id=IDENTIFIER Struct_declaration_list=struct_declaration_list)
	 *     )
	 */
	protected void sequence_struct_or_union_specifier(ISerializationContext context, struct_or_union_specifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     translation_unitR returns translation_unitR
	 *
	 * Constraint:
	 *     (External_declaration=external_declaration rec+=translation_unitR*)
	 */
	protected void sequence_translation_unitR(ISerializationContext context, translation_unitR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     translation_unit returns translation_unit
	 *
	 * Constraint:
	 *     (External_declaration=external_declaration Translation_unitR=translation_unitR?)
	 */
	protected void sequence_translation_unit(ISerializationContext context, translation_unit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type_name returns type_name
	 *     atomic_type_specifier returns type_name
	 *     type_specifier returns type_name
	 *
	 * Constraint:
	 *     (Specifier_qualifier_list=specifier_qualifier_list ad=abstract_declarator)
	 */
	protected void sequence_type_name(ISerializationContext context, type_name semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TYPE_NAME__SPECIFIER_QUALIFIER_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TYPE_NAME__SPECIFIER_QUALIFIER_LIST));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TYPE_NAME__AD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TYPE_NAME__AD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getType_nameAccess().getSpecifier_qualifier_listSpecifier_qualifier_listParserRuleCall_0_0_0(), semanticObject.getSpecifier_qualifier_list());
		feeder.accept(grammarAccess.getType_nameAccess().getAdAbstract_declaratorParserRuleCall_0_1_0(), semanticObject.getAd());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     type_qualifier_listR returns type_qualifier_listR
	 *
	 * Constraint:
	 *     (Type_qualifier=type_qualifier rec+=type_qualifier_listR*)
	 */
	protected void sequence_type_qualifier_listR(ISerializationContext context, type_qualifier_listR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type_qualifier_list returns type_qualifier_list
	 *     abstract_declarator returns type_qualifier_list
	 *     pointer returns type_qualifier_list
	 *
	 * Constraint:
	 *     (Type_qualifier=type_qualifier Type_qualifier_listR=type_qualifier_listR?)
	 */
	protected void sequence_type_qualifier_list(ISerializationContext context, type_qualifier_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     cast_expression returns unary_expression
	 *     unary_expression returns unary_expression
	 *
	 * Constraint:
	 *     (rec+=unary_expression+ | rec+=unary_expression+ | (Unary_operator=unary_operator ce=cast_expression))
	 */
	protected void sequence_unary_expression(ISerializationContext context, unary_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
